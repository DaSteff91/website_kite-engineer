name: Prepare for build and push
on:
  push:
    branches:
      - dev
      - development
      - workflow-test

jobs:
  translate-content:
    name: Translates new content
    permissions:
      contents: write
      issues: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - name: Get current run ID as Env
        env:
          RUN_ID: ${{ github.run_id }}
        run: echo "Current run ID is $RUN_ID"

      - name: Checkout repo (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node server environment
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Check for changes in en-US.json
        id: check_for_changes
        run: |
          set -euo pipefail

          BEFORE_SHA="${{ github.event.before }}"
          AFTER_SHA="${{ github.sha }}"

          # Handle first push to branch (before == all zeros)
          if [ "$BEFORE_SHA" = "0000000000000000000000000000000000000000" ]; then
            echo "First push to this branch – diffing against empty tree."
            BEFORE_SHA="$(git hash-object -t tree /dev/null)"
          fi

          echo "Comparing commits: before=$BEFORE_SHA after=$AFTER_SHA"

          CHANGED_FILES="$(git diff --name-only "$BEFORE_SHA" "$AFTER_SHA")"

          echo "Files with changes in this push:"
          echo "$CHANGED_FILES"

          # export outputs in the modern recommended way
          {
            echo "files<<EOF"
            echo "$CHANGED_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          if echo "$CHANGED_FILES" | grep -q 'messages/en-US.json'; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute removed keys across locales
        run: |
          set -euo pipefail

          BEFORE_SHA="${{ github.event.before }}"
          AFTER_SHA="${{ github.sha }}"

          # Handle first push to branch (before == all zeros)
          if [ "$BEFORE_SHA" = "0000000000000000000000000000000000000000" ]; then
            echo "First push to this branch – diffing against previous commit on AFTER."
            BEFORE_SHA="${AFTER_SHA}~1"
          fi

          echo "Computing removed keys between $BEFORE_SHA and $AFTER_SHA"

          node <<'JS'
          const fs = require('fs');
          const { execSync } = require('child_process');
          const path = require('path');

          function safeParse(jsonStr) {
            if (!jsonStr || !jsonStr.trim()) return {};
            try {
              return JSON.parse(jsonStr);
            } catch (e) {
              console.warn("Warning: failed to parse JSON, treating as {}:", e.message);
              return {};
            }
          }

          function loadJsonAtCommit(sha, filePath) {
            try {
              const out = execSync(`git show ${sha}:${filePath}`, { encoding: 'utf8' });
              return safeParse(out);
            } catch (e) {
              // file might not exist in that commit -> treat as empty
              console.log(`No ${filePath} at ${sha}, treating as empty object.`);
              return {};
            }
          }

          function loadJsonWorkingTree(filePath) {
            if (!fs.existsSync(filePath)) return {};
            const content = fs.readFileSync(filePath, 'utf8');
            return safeParse(content);
          }

          // Collect all dot-path keys from a nested object
          function collectKeys(obj, prefix = '', out = new Set()) {
            if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) {
              // leaf -> record path
              if (prefix) out.add(prefix);
              return out;
            }
            for (const key of Object.keys(obj)) {
              const nextPrefix = prefix ? `${prefix}.${key}` : key;
              collectKeys(obj[key], nextPrefix, out);
            }
            return out;
          }

          // Build nested structure from a set of dot paths
          function nestFromPaths(paths) {
            const root = {};
            for (const p of paths) {
              const parts = p.split('.');
              let cur = root;
              for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (i === parts.length - 1) {
                  // leaf
                  cur[part] = true;
                } else {
                  if (!cur[part] || typeof cur[part] !== 'object' || Array.isArray(cur[part])) {
                    cur[part] = {};
                  }
                  cur = cur[part];
                }
              }
            }
            return root;
          }

          // SHAs from env (passed via shell)
          const BEFORE_SHA = process.env.BEFORE_SHA || '';
          const AFTER_SHA = process.env.AFTER_SHA || '';

          const files = [
            'messages/en-US.json',
            'messages/de-DE.json',
            'messages/pt-BR.json',
          ];

          // 1) Load "before" and "after" snapshots for all three locales
          const beforeSnapshots = {};
          const afterSnapshots = {};

          for (const f of files) {
            beforeSnapshots[f] = loadJsonAtCommit(BEFORE_SHA, f);
            afterSnapshots[f]  = loadJsonWorkingTree(f);
          }

          // 2) Collect removed keys per file (dot paths)
          const removedPaths = new Set();

          for (const f of files) {
            const beforeKeys = collectKeys(beforeSnapshots[f]);
            const afterKeys  = collectKeys(afterSnapshots[f]);

            for (const k of beforeKeys) {
              if (!afterKeys.has(k)) {
                // key existed before in this file but is gone now -> mark as removed
                removedPaths.add(k);
              }
            }
          }

          // 3) Create nested removed-keys structure
          const removedNested = nestFromPaths(removedPaths);

          const outPath = '/tmp/removed-keys.json';
          fs.writeFileSync(outPath, JSON.stringify(removedNested, null, 2), 'utf8');

          console.log("Removed keys (nested) written to", outPath);
          console.log(JSON.stringify(removedNested, null, 2));
          JS

      - name: Apply removed keys to all locale files
        run: |
          set -euo pipefail

          if [ ! -f /tmp/removed-keys.json ]; then
            echo "No /tmp/removed-keys.json found, skipping removal."
            exit 0
          fi

          echo "Applying removed keys from /tmp/removed-keys.json to locale files..."

          node <<'JS'
          const fs = require('fs');
          const path = require('path');

          const removedPath = '/tmp/removed-keys.json';

          if (!fs.existsSync(removedPath)) {
            console.log('No removed-keys.json present, nothing to do.');
            process.exit(0);
          }

          function safeReadJson(filePath, fallback = {}) {
            if (!fs.existsSync(filePath) || fs.statSync(filePath).size === 0) {
              return fallback;
            }
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.warn(`Warning: failed to parse ${filePath}, using fallback: ${e.message}`);
              return fallback;
            }
          }

          function safeWriteJson(filePath, obj) {
            const dir = path.dirname(filePath);
            if (dir && !fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), 'utf8');
          }

          function isPlainObject(value) {
            return (
              value !== null &&
              typeof value === 'object' &&
              !Array.isArray(value)
            );
          }

          function deleteKeys(targetObj, removedObj) {
            if (!isPlainObject(targetObj) || !isPlainObject(removedObj)) {
              return;
            }

            for (const key of Object.keys(removedObj)) {
              if (!Object.prototype.hasOwnProperty.call(targetObj, key)) {
                continue; // nothing to delete here
              }

              const remVal = removedObj[key];
              const tgtVal = targetObj[key];

              // Leaf: removedObj[key] === true -> delete key
              if (remVal === true) {
                delete targetObj[key];
                continue;
              }

              // Nested: both sides plain objects
              if (isPlainObject(remVal) && isPlainObject(tgtVal)) {
                deleteKeys(tgtVal, remVal);

                // If nested object is now empty, clean it up
                if (isPlainObject(tgtVal) && Object.keys(tgtVal).length === 0) {
                  delete targetObj[key];
                }
              }
            }
          }

          const removed = safeReadJson(removedPath, {});
          if (!isPlainObject(removed) || Object.keys(removed).length === 0) {
            console.log('removed-keys.json is empty, nothing to remove.');
            process.exit(0);
          }

          const localeFiles = [
            'messages/en-US.json',
            'messages/de-DE.json',
            'messages/pt-BR.json',
          ];

          for (const file of localeFiles) {
            console.log(`Processing removals in ${file}...`);
            const current = safeReadJson(file, {});
            const before = JSON.stringify(current);

            deleteKeys(current, removed);

            const after = JSON.stringify(current);
            if (before !== after) {
              console.log(`  -> ${file} changed, writing updated JSON.`);
              safeWriteJson(file, current);
            } else {
              console.log(`  -> ${file} unchanged.`);
            }
          }

          console.log('Finished applying removed keys to all locale files.');
          JS

      - name: Create the diff between the latest and previous push in en-US.json
        if: steps.check_for_changes.outputs.changed == 'true'
        id: compute_diff
        run: |
          set -euo pipefail

          PREV_COMMIT="${{ github.event.before }}"
          CUR_COMMIT="${{ github.sha }}"
          FILE_PATH="messages/en-US.json"

          # Get previous content and check availability of the file
          if git cat-file -e "${PREV_COMMIT}:${FILE_PATH}" 2>/dev/null; then
            git show "${PREV_COMMIT}:${FILE_PATH}" > /tmp/en-US.prev.json
          else
            # File didn´t exist in the previous commit
            echo '{}' > /tmp/en-US.prev.json
          fi

          # Current content (must exist)
          if [ -f "$FILE_PATH" ]; then
            cp "$FILE_PATH" /tmp/en-US.cur.json
          else
            # IF removed in the commit, treat as empty
            echo '{}' > /tmp/en-US.cur.json
          fi

          # Node script: reads prev & cur, computes nested diff (added/changed only), writes result
          node <<'NODE'
          const fs = require('fs');

          function readJson(path) {
            try {
              return JSON.parse(fs.readFileSync(path, 'utf8'));
            } catch (e) {
              console.error(`Failed to parse ${path}:`, e.message);
              process.exit(2);
            }
          }

          // deepEqual that handles primitives, arrays, objects (order matters for arrays and object keys compared by keys)
          function deepEqual(a, b) {
            if (a === b) return true;

            // handle NaN
            if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) return true;

            if (a == null || b == null) return a === b; // covers null/undefined

            if (typeof a !== typeof b) return false;

            if (typeof a !== 'object') return a === b;

            // Arrays
            if (Array.isArray(a) || Array.isArray(b)) {
              if (!Array.isArray(a) || !Array.isArray(b)) return false;
              if (a.length !== b.length) return false;
              for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) return false;
              }
              return true;
            }

            // Plain objects
            const aKeys = Object.keys(a);
            const bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;
            // ensure same keys
            for (const k of aKeys) {
              if (!Object.prototype.hasOwnProperty.call(b, k)) return false;
              if (!deepEqual(a[k], b[k])) return false;
            }
            return true;
          }

          // computeDiff: only include keys present in `cur` (so deletions are ignored)
          // returns `undefined` if no change at this node, otherwise returns an object/primitive representing the new value
          function computeDiff(prev, cur) {
            // If either side is a primitive (or null), compare directly
            if (typeof prev !== 'object' || prev === null || typeof cur !== 'object' || cur === null) {
              if (deepEqual(prev, cur)) return undefined;
              return cur;
            }

            const keys = Object.keys(cur); // only iterate current keys -> deletions ignored
            const out = {};
            let any = false;

            for (const k of keys) {
              if (!(k in prev)) {
                // added key (or previously missing)
                out[k] = cur[k];
                any = true;
                continue;
              }

              const subPrev = prev[k];
              const subCur = cur[k];

              if (typeof subPrev === 'object' && subPrev !== null && typeof subCur === 'object' && subCur !== null) {
                const subDiff = computeDiff(subPrev, subCur);
                if (subDiff !== undefined) {
                  out[k] = subDiff;
                  any = true;
                }
              } else if (!deepEqual(subPrev, subCur)) {
                out[k] = subCur;
                any = true;
              }
            }

            return any ? out : undefined;
          }

          const prev = readJson('/tmp/en-US.prev.json');
          const cur = readJson('/tmp/en-US.cur.json');

          const diff = computeDiff(prev, cur) || {};

          fs.writeFileSync('/tmp/en-US.changed.json', JSON.stringify(diff, null, 2), 'utf8');
          console.log('Wrote /tmp/en-US.changed.json (diff object).');
          NODE

          # export path of diff as step output
          echo "diff_path=/tmp/en-US.changed.json" >> $GITHUB_OUTPUT

      - name: Prepare mapping for translation and reconstruction
        if: steps.check_for_changes.outputs.changed == 'true'
        id: translation_preparation
        run: |
          set -euo pipefail
          node <<'JS'

          const fs = require('fs');

          // Read the path to changed.json from GitHub output or env variable
          const diffPath = process.env.DIFF_PATH || '/tmp/en-US.changed.json';

          if (!fs.existsSync(diffPath)) {
            console.error(`Changed file not found at ${diffPath}`);
            process.exit(1);
          }

          // Read and parse changed.json
          let changedJson;
          try {
            changedJson = JSON.parse(fs.readFileSync(diffPath, 'utf8'));
          } catch (e) {
            console.error(`Failed to parse ${diffPath}:`, e.message);
            process.exit(2);
          }

          /**
          * Recursively traverses a nested object to extract leaf string values.
          * Returns both nested structure and flat list with dot-notation paths.
          * @param {Object} obj - JSON object to traverse
          * @param {string} prefix - dot-notation prefix
          * @param {Object} nestedResult - accumulates nested structure
          * @param {Array} flatResult - accumulates flat array
          */
          function extractLeafStringsDual(obj, prefix = '', nestedResult = {}, flatResult = []) {
            for (const key of Object.keys(obj)) {
              const value = obj[key];
              const fullPath = prefix ? `${prefix}.${key}` : key;

              if (value && typeof value === 'object' && !Array.isArray(value)) {
                nestedResult[key] = {};
                extractLeafStringsDual(value, fullPath, nestedResult[key], flatResult);
              } else if (typeof value === 'string') {
                nestedResult[key] = value;
                flatResult.push({ path: fullPath, value });
              }
            }
            return { nested: nestedResult, flat: flatResult };
          }

          // Run extraction
          const { nested, flat } = extractLeafStringsDual(changedJson);

          // Write outputs
          fs.writeFileSync('/tmp/en-US.keys-nested.json', JSON.stringify(nested, null, 2), 'utf8');
          fs.writeFileSync('/tmp/en-US.keys-dot.json', JSON.stringify(flat, null, 2), 'utf8');
          const content = fs.readFileSync('/tmp/en-US.keys-nested.json','utf8')
          console.log('This is \'/tmp/en-US.keys-nested.json\' content aka the delta:\n' + content);
          JS

      - name: Start LibreTranslate container on server
        if: steps.check_for_changes.outputs.changed == 'true'
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_PRIVATE_SSH_KEY }}
          script: |
            set -euo pipefail

            cd /home/steff_deployment/website_kite-engineer/libretranslate_docker

            echo "Starting LibreTranslate service via docker compose..."
            docker compose up -d

            echo "Waiting for LibreTranslate container health status..."
            MAX_RETRIES=24   # ~2 minutes total (24 * 5s)
            SLEEP_SECONDS=5

            i=1
            while [ "$i" -le "$MAX_RETRIES" ]; do
              STATUS=$(docker inspect -f '{{.State.Health.Status}}' libretranslate 2>/dev/null || echo "starting")
              echo "Attempt $i/$MAX_RETRIES: current status=$STATUS"

              if [ "$STATUS" = "healthy" ]; then
                echo "LibreTranslate is healthy and ready."
                exit 0
              fi

              if [ "$STATUS" = "unhealthy" ]; then
                echo "LibreTranslate container is unhealthy. Aborting."
                docker logs libretranslate || true
                exit 1
              fi

              i=$((i+1))
              sleep "$SLEEP_SECONDS"
            done

            echo "Timed out waiting for LibreTranslate to become healthy."
            docker logs libretranslate || true
            exit 1

      - name: Translate nested keys (target = de)
        if: steps.check_for_changes.outputs.changed == 'true'
        env:
          TARGET_LANG: de
          TRANSLATE_API_KEY: ${{ secrets.TRANSLATE_API_KEY }}
          KEYS_NESTED: /tmp/en-US.keys-nested.json
          OUTPUT_TRANSLATED: /tmp/en-US.changed.translated.de.json
          OUTPUT_ERRORS: /tmp/en-US.translation-errors.de.json
          API_URL: https://translate.kite-engineer.de/translate
        run: |
          set -euo pipefail

          node -v || (echo "Node not found" && exit 2)

          node <<'JS'
          (async () => {
            const fs = require('fs');

            const nestedTemplatePath = process.env.KEYS_NESTED;
            const outTranslatedPath = process.env.OUTPUT_TRANSLATED;
            const outErrorsPath = process.env.OUTPUT_ERRORS;
            const apiUrl = process.env.API_URL;
            const apiKey = process.env.TRANSLATE_API_KEY;
            const target = process.env.TARGET_LANG;

            if (!fs.existsSync(nestedTemplatePath)) {
              console.error(`Nested template missing: ${nestedTemplatePath}`);
              process.exit(1);
            }

            const nested = JSON.parse(fs.readFileSync(nestedTemplatePath, 'utf8'));
            const stat = fs.statSync(nestedTemplatePath);
            console.log(`Loaded nested template: ${nestedTemplatePath} (size=${stat.size}, mtime=${stat.mtime.toISOString()})`);
            console.log('Nested template (preview):', JSON.stringify(nested, null, 2).slice(0, 2000));

            // Helper: build request body for the API
            function buildRequestBody(q) {
              return {
                q,
                source: "auto",
                target,
                format: "text",
                api_key: apiKey
              };
            }

            const errors = [];
            let successCount = 0;
            let failCount = 0;

            // Traverse nested object recursively and translate string leaves in-place.
            async function traverseAndTranslate(obj, prefix = '') {
              for (const key of Object.keys(obj)) {
                const value = obj[key];
                const path = prefix ? `${prefix}.${key}` : key;

                if (value && typeof value === 'object' && !Array.isArray(value)) {
                  await traverseAndTranslate(value, path);
                  continue;
                }

                if (typeof value === 'string') {
                  if (value.trim() === '') {
                    obj[key] = '';
                    continue;
                  }

                  const body = buildRequestBody(value);

                  // create a nonce for this request
                  const nonce = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                  console.log(`[${nonce}] request at ${new Date().toISOString()} path=${path}`);

                  let resp;
                  try {
                    resp = await fetch(apiUrl, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-Debug-Nonce': nonce,
                        'Cache-Control': 'no-cache'
                      },
                      body: JSON.stringify(body),
                    });
                  } catch (err) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: err.message }
                    });
                    console.log(`[${nonce}] fetch failed: ${err.message}`);
                    continue;
                  }

                  let respText = '';
                  try {
                    // log response status & headers
                    console.log(`[${nonce}] response at ${new Date().toISOString()} status=${resp.status} statusText=${resp.statusText}`);
                    for (const [k, v] of resp.headers.entries()) {
                      console.log(`[${nonce}] resp-header ${k}: ${v}`);
                    }

                    respText = await resp.text();
                    console.log(`API Response raw: ${respText}`);

                    if (!resp.ok) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText
                      });
                      continue;
                    }

                    let parsed;
                    try {
                      parsed = JSON.parse(respText);
                      console.log(`[${nonce}] API Response parsed: ${JSON.stringify(parsed)}`);
                    } catch (e) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText,
                        parseError: e.message
                      });
                      continue;
                    }

                    const translatedText = parsed && parsed.translatedText;
                    console.log(`[${nonce}] Extracted translatedText: ${JSON.stringify(translatedText)}`);
                    if (typeof translatedText !== 'string') {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseJson: parsed,
                        note: "translatedText missing or not a string"
                      });
                      continue;
                    }

                    obj[key] = translatedText;
                    successCount++;
                  } catch (e) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: e.message }
                    });
                    console.log(`[${nonce}] unexpected error: ${e.message}`);
                    continue;
                  }
                }
              }
            }

            await traverseAndTranslate(nested, '');

            const tmpOut = outTranslatedPath + '.tmp';
            fs.writeFileSync(tmpOut, JSON.stringify(nested, null, 2), 'utf8');

            try {
              const parsedCheck = JSON.parse(fs.readFileSync(tmpOut, 'utf8'));
              fs.renameSync(tmpOut, outTranslatedPath);
            } catch (e) {
              errors.push({ note: 'validation_failed', message: e.message });

              console.error('Validation of output JSON failed:', e.message);
            }

            fs.writeFileSync(outErrorsPath, JSON.stringify({ successCount, failCount, errors }, null, 2), 'utf8');

            const outStat = fs.statSync(outTranslatedPath);
            console.log(`Wrote translated file: ${outTranslatedPath} (size=${outStat.size}, mtime=${outStat.mtime.toISOString()})`);
            console.log('Translated file (preview):', fs.readFileSync(outTranslatedPath,'utf8').slice(0,2000));

            console.log(`Translation run complete for target=${target}: success=${successCount}, fail=${failCount}`);
            if (failCount > 0) {
              console.log(`See error summary: ${outErrorsPath}`);
            } else {
              console.log(`All keys translated successfully. Output: ${outTranslatedPath}`);
            }
          })();
          JS

      - name: Translate nested keys (target = pt-BR)
        if: steps.check_for_changes.outputs.changed == 'true'
        env:
          TARGET_LANG: pt-BR
          TRANSLATE_API_KEY: ${{ secrets.TRANSLATE_API_KEY }}
          KEYS_NESTED: /tmp/en-US.keys-nested.json
          OUTPUT_TRANSLATED: /tmp/en-US.changed.translated.pt-BR.json
          OUTPUT_ERRORS: /tmp/en-US.translation-errors.pt-BR.json
          API_URL: https://translate.kite-engineer.de/translate
        run: |
          set -euo pipefail

          node -v || (echo "Node not found" && exit 2)

          node <<'JS'
          (async () => {
            const fs = require('fs');

            const nestedTemplatePath = process.env.KEYS_NESTED;
            const outTranslatedPath = process.env.OUTPUT_TRANSLATED;
            const outErrorsPath = process.env.OUTPUT_ERRORS;
            const apiUrl = process.env.API_URL;
            const apiKey = process.env.TRANSLATE_API_KEY;
            const target = process.env.TARGET_LANG;

            if (!fs.existsSync(nestedTemplatePath)) {
              console.error(`Nested template missing: ${nestedTemplatePath}`);
              process.exit(1);
            }

            const nested = JSON.parse(fs.readFileSync(nestedTemplatePath, 'utf8'));
            const stat = fs.statSync(nestedTemplatePath);
            console.log(`Loaded nested template: ${nestedTemplatePath} (size=${stat.size}, mtime=${stat.mtime.toISOString()})`);
            console.log('Nested template (preview):', JSON.stringify(nested, null, 2).slice(0, 2000));

            // Helper: build request body for the API
            function buildRequestBody(q) {
              return {
                q,
                source: "auto",
                target,
                format: "text",
                api_key: apiKey
              };
            }

            const errors = [];
            let successCount = 0;
            let failCount = 0;

            // Traverse nested object recursively and translate string leaves in-place.
            async function traverseAndTranslate(obj, prefix = '') {
              // Iterate keys to keep original order
              for (const key of Object.keys(obj)) {
                const value = obj[key];
                const path = prefix ? `${prefix}.${key}` : key;

                if (value && typeof value === 'object' && !Array.isArray(value)) {
                  // recurse
                  await traverseAndTranslate(value, path);
                  continue;
                }

                if (typeof value === 'string') {
                  // Skip empty strings (choose to keep empty translated)
                  if (value.trim() === '') {
                    obj[key] = '';
                    continue;
                  }

                  const body = buildRequestBody(value);

                  // create a nonce for this request
                  const nonce = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                  console.log(`[${nonce}] request at ${new Date().toISOString()} path=${path}`);

                  let resp;
                  try {
                    resp = await fetch(apiUrl, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-Debug-Nonce': nonce,
                        'Cache-Control': 'no-cache'
                      },
                      body: JSON.stringify(body),
                    });
                  } catch (err) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: err.message }
                    });
                    console.log(`[${nonce}] fetch failed: ${err.message}`);
                    continue;
                  }

                  let respText = '';
                  try {
                    // log response status & headers
                    console.log(`[${nonce}] response at ${new Date().toISOString()} status=${resp.status} statusText=${resp.statusText}`);
                    for (const [k, v] of resp.headers.entries()) {
                      console.log(`[${nonce}] resp-header ${k}: ${v}`);
                    }

                    respText = await resp.text();
                    console.log(`API Response raw: ${respText}`);

                    if (!resp.ok) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText
                      });
                      continue;
                    }

                    let parsed;
                    try {
                      parsed = JSON.parse(respText);
                      console.log(`[${nonce}] API Response parsed: ${JSON.stringify(parsed)}`);
                    } catch (e) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText,
                        parseError: e.message
                      });
                      continue;
                    }

                    const translatedText = parsed && parsed.translatedText;
                    console.log(`[${nonce}] Extracted translatedText: ${JSON.stringify(translatedText)}`);
                    if (typeof translatedText !== 'string') {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseJson: parsed,
                        note: "translatedText missing or not a string"
                      });
                      continue;
                    }

                    // success: replace value in-place
                    obj[key] = translatedText;
                    successCount++;
                  } catch (e) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: e.message }
                    });
                    console.log(`[${nonce}] unexpected error: ${e.message}`);
                    continue;
                  }
                } // end if string
                // non-strings (numbers, booleans, null, arrays) are left unchanged
              }
            }

            // run traversal & translation
            await traverseAndTranslate(nested, '');

            // Write outputs (atomic-ish: write tmp then rename)
            const tmpOut = outTranslatedPath + '.tmp';
            fs.writeFileSync(tmpOut, JSON.stringify(nested, null, 2), 'utf8');

            // validate by parsing back
            try {
              const parsedCheck = JSON.parse(fs.readFileSync(tmpOut, 'utf8'));
              // move into place
              fs.renameSync(tmpOut, outTranslatedPath);
            } catch (e) {
              errors.push({ note: 'validation_failed', message: e.message });
              // keep tmp file for debugging
              console.error('Validation of output JSON failed:', e.message);
            }
            fs.writeFileSync(outErrorsPath, JSON.stringify({ successCount, failCount, errors }, null, 2), 'utf8');

            const outStat = fs.statSync(outTranslatedPath);
            console.log(`Wrote translated file: ${outTranslatedPath} (size=${outStat.size}, mtime=${outStat.mtime.toISOString()})`);
            console.log('Translated file (preview):', fs.readFileSync(outTranslatedPath,'utf8').slice(0,2000));

            console.log(`Translation run complete for target=${target}: success=${successCount}, fail=${failCount}`);
            if (failCount > 0) {
              console.log(`See error summary: ${outErrorsPath}`);
            } else {
              console.log(`All keys translated successfully. Output: ${outTranslatedPath}`);
            }
          })();
          JS

      - name: Merge DE translations into existing de-DE.json
        run: |
          set -euo pipefail

          if [ -f /tmp/en-US.changed.translated.de.json ]; then
            echo "Translated (incoming):"
            head -n 50 /tmp/en-US.changed.translated.de.json
          else
            echo "No translated file at /tmp/en-US.changed.translated.de.json"
          fi

          if [ -f messages/de-DE.json ]; then
            echo "Repo target BEFORE merge:"
            head -n 50 messages/de-DE.json
          else
            echo "Repo target messages/de-DE.json does not exist yet."
          fi

          node <<'JS'
          const fs = require('fs');
          const path = require('path');

          // Paths
          const translatedPath = '/tmp/en-US.changed.translated.de.json';
          const targetPath = 'messages/de-DE.json';
          const metaPath = 'messages/.messages-meta/de-DE.meta.json';
          const reviewPath = 'messages/.messages-manual-review/de-DE.review.json';
          const enDiffPath = '/tmp/en-US.keys-nested.json'; // nested English diff (changed keys)

          // --- helpers ----------------------------------------------------

          function ensureDirForFile(filePath) {
            const dir = path.dirname(filePath);
            if (dir && !fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
          }

          function safeReadJson(filePath, fallback = {}) {
            if (!fs.existsSync(filePath) || fs.statSync(filePath).size === 0) {
              return fallback;
            }
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.warn(`Warning: failed to parse ${filePath}, using fallback: ${e.message}`);
              return fallback;
            }
          }

          function safeWriteJson(filePath, obj) {
            ensureDirForFile(filePath);
            fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), 'utf8');
          }

          // --- load translated diff ---------------------------------------

          let translated = {};
          if (fs.existsSync(translatedPath)) {
            translated = safeReadJson(translatedPath, {});
            console.log("de-DE translation available for merge.");
          } else {
            console.log("No de-DE translation available — running only manual detection.");
          }

          // --- load English nested diff (same keys, en-US side) -----------

          const enDiff = safeReadJson(enDiffPath, {});

          // --- load target locale file (de-DE.json) -----------------------

          let target = safeReadJson(targetPath, {});
          if (Object.keys(target).length === 0) {
            console.log(`${targetPath} missing or empty — starting from empty object`);
          }

          // --- load / initialize meta + review (nested) -------------------

          let meta = safeReadJson(metaPath, {});
          let review = safeReadJson(reviewPath, {});

          function isPlainObject(value) {
            return (
              value !== null &&
              typeof value === 'object' &&
              !Array.isArray(value)
            );
          }

          // helper to ensure nested object structure for meta / target
          function ensureNestedObject(obj, key) {
            if (!isPlainObject(obj[key])) {
              obj[key] = {};
            }
            return obj[key];
          }

          function detectManualDiffs(targetObj, metaObj, reviewObj, enFullObj = {}) {
            const nowIso = new Date().toISOString();

            function traverse(targetNode, metaNode, reviewNode, enNode) {
              for (const key of Object.keys(targetNode)) {
                const targetVal = targetNode[key];

                // Nested structure?
                if (isPlainObject(targetVal)) {
                  if (!isPlainObject(metaNode[key])) metaNode[key] = {};
                  if (!isPlainObject(reviewNode[key])) reviewNode[key] = {};
                  if (!isPlainObject(enNode?.[key])) enNode[key] = {};

                  traverse(targetVal, metaNode[key], reviewNode[key], enNode[key]);
                  continue;
                }

                let metaEntry = metaNode[key];
                if (!metaEntry || typeof metaEntry !== "object") continue;

                const lastAuto = metaEntry.lastAutoTarget;
                const status = metaEntry.status;
                const englishBefore = metaEntry.lastSource;
                const englishNow = enNode?.[key] || englishBefore;

                if (status === "auto" &&
                    lastAuto != null &&
                    targetVal !== lastAuto) {

                  metaEntry.status = "manual";

                  reviewNode[key] = {
                    englishBefore,
                    englishNow,
                    previousAutoTarget: lastAuto,
                    currentManualValue: targetVal,
                    detectedAt: nowIso
                  };
                }
              }
            }

            traverse(targetObj, metaObj, reviewObj, enFullObj);
          }

          function mergeNested(targetObj, sourceObj, enObj, metaObj, reviewObj) {
            const nowIso = new Date().toISOString();

            for (const key of Object.keys(sourceObj)) {
              const srcVal = sourceObj[key];
              const enVal =
                isPlainObject(enObj) && Object.prototype.hasOwnProperty.call(enObj, key)
                  ? enObj[key]
                  : undefined;

              const targetHasKey = Object.prototype.hasOwnProperty.call(targetObj, key);
              const currentTargetVal = targetHasKey ? targetObj[key] : undefined;

              if (isPlainObject(srcVal)) {
                // nested object branch
                const tgtChild = ensureNestedObject(targetObj, key);
                const metaChild = ensureNestedObject(metaObj, key);
                const reviewChild = ensureNestedObject(reviewObj, key);

                const enChild =
                  isPlainObject(enVal) ? enVal : {};

                mergeNested(tgtChild, srcVal, enChild, metaChild, reviewChild);
              } else {
                // --- LEAF BRANCH: protect manual translations ----------------

                // Ensure meta leaf object exists (or reuse existing)
                if (!isPlainObject(metaObj[key])) {
                  metaObj[key] = {
                    status: targetHasKey ? "manual" : "auto",
                    lastSource: null,
                    lastAutoTarget: null,
                    updatedAt: null,
                  };
                }

                const entry = metaObj[key];
                const previousLastAuto = entry.lastAutoTarget;

                // Detect manual override:
                // If this key was auto-managed and the current stored translation
                // differs from the last auto output -> someone edited it by hand.
                if (
                  entry.status === "auto" &&
                  previousLastAuto != null &&
                  targetHasKey &&
                  currentTargetVal !== previousLastAuto
                ) {
                  entry.status = "manual";
                }

                // If now marked as manual → DO NOT overwrite this key
                if (entry.status === "manual") {
                  // We deliberately leave lastSource/lastAutoTarget/updatedAt unchanged here.
                  // Later we will use this to drive manual review.
                  continue;
                }

                // Auto-managed: overwrite and record metadata
                targetObj[key] = srcVal;

                // Only update lastSource if we actually have English text for this key
                if (typeof enVal === 'string') {
                  entry.lastSource = enVal;
                }

                entry.lastAutoTarget = srcVal;
                entry.updatedAt = nowIso;
              }
            }
          }

          // Detect manual edits even when EN did not change
          detectManualDiffs(target, meta, review, enDiff);

          // Then apply auto-translations (if available)
          if (Object.keys(translated).length > 0) {
            mergeNested(target, translated, enDiff, meta, review);
          }

          // --- write back target + meta/review ----------------------------

          ensureDirForFile(targetPath);
          fs.writeFileSync(targetPath, JSON.stringify(target, null, 2), 'utf8');
          console.log(`Merged DE translations into ${targetPath}`);

          safeWriteJson(metaPath, meta);
          safeWriteJson(reviewPath, review);
          console.log(`Updated meta at ${metaPath} and kept review at ${reviewPath}.`);
          JS

          git add \
            messages/de-DE.json \
            messages/.messages-meta \
            messages/.messages-manual-review

          # show staged diff if any
          if git diff --cached --quiet -- messages/de-DE.json; then
            echo "No staged changes for messages/de-DE.json"
          else
            echo "Staged diff for messages/de-DE.json:"
            git --no-pager diff --cached -- messages/de-DE.json || true
          fi

          # commit if there are staged changes
          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            SOURCE_SHA="${{ github.event.after }}"
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "[skip ci] auto translation (from commit ${SOURCE_SHA})"
            echo "Committed automated translation changes."
            # show what was committed
            echo "Files in last commit:"
            git show --name-only --pretty="" HEAD || true
            echo "Preview of committed messages/de-DE.json:"
            git show HEAD:messages/de-DE.json | head -n 50 || true
            
            TARGET_BRANCH="${{ github.ref_name }}"
            echo "Pushing to origin ${TARGET_BRANCH}..."
            git push origin "HEAD:${TARGET_BRANCH}" && echo "push ok" || echo "push failed"

          fi

      - name: Merge PT-BR translations into existing pt-BR.json
        run: |
          set -euo pipefail

          if [ -f /tmp/en-US.changed.translated.pt-BR.json ]; then
            echo "Translated (incoming):"
            head -n 50 /tmp/en-US.changed.translated.pt-BR.json
          else
            echo "No translated file at /tmp/en-US.changed.translated.pt-BR.json"
          fi

          if [ -f messages/pt-BR.json ]; then
            echo "Repo target BEFORE merge:"
            head -n 50 messages/pt-BR.json
          else
            echo "Repo target messages/pt-BR.json does not exist yet."
          fi

          node <<'JS'
          const fs = require('fs');
          const path = require('path');

          // Paths
          const translatedPath = '/tmp/en-US.changed.translated.pt-BR.json';
          const targetPath = 'messages/pt-BR.json';
          const metaPath = 'messages/.messages-meta/pt-BR.meta.json';
          const reviewPath = 'messages/.messages-manual-review/pt-BR.review.json';
          const enDiffPath = '/tmp/en-US.keys-nested.json'; // nested English diff (changed keys)

          // --- helpers ----------------------------------------------------

          function ensureDirForFile(filePath) {
            const dir = path.dirname(filePath);
            if (dir && !fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
          }

          function safeReadJson(filePath, fallback = {}) {
            if (!fs.existsSync(filePath) || fs.statSync(filePath).size === 0) {
              return fallback;
            }
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.warn(`Warning: failed to parse ${filePath}, using fallback: ${e.message}`);
              return fallback;
            }
          }

          function safeWriteJson(filePath, obj) {
            ensureDirForFile(filePath);
            fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), 'utf8');
          }

          // --- load translated diff ---------------------------------------

          let translated = {};
          if (fs.existsSync(translatedPath)) {
            translated = safeReadJson(translatedPath, {});
            console.log("pt-BR translation available for merge.");
          } else {
            console.log("No pt-BR translation available — running only manual detection.");
          }

          // --- load English nested diff (same keys, en-US side) -----------

          const enDiff = safeReadJson(enDiffPath, {});

          // --- load target locale file (pt-BR.json) -----------------------

          let target = safeReadJson(targetPath, {});
          if (Object.keys(target).length === 0) {
            console.log(`${targetPath} missing or empty — starting from empty object`);
          }

          // --- load / initialize meta + review ----------------------------

          let meta = safeReadJson(metaPath, {});
          let review = safeReadJson(reviewPath, {});

          function isPlainObject(value) {
            return (
              value !== null &&
              typeof value === 'object' &&
              !Array.isArray(value)
            );
          }

          function ensureNestedObject(obj, key) {
            if (!isPlainObject(obj[key])) {
              obj[key] = {};
            }
            return obj[key];
          }

          function detectManualDiffs(targetObj, metaObj, reviewObj, enFullObj = {}) {
            const nowIso = new Date().toISOString();

            function traverse(targetNode, metaNode, reviewNode, enNode) {
              for (const key of Object.keys(targetNode)) {
                const targetVal = targetNode[key];

                if (isPlainObject(targetVal)) {
                  if (!isPlainObject(metaNode[key])) metaNode[key] = {};
                  if (!isPlainObject(reviewNode[key])) reviewNode[key] = {};
                  if (!isPlainObject(enNode?.[key])) enNode[key] = {};
                  traverse(targetVal, metaNode[key], reviewNode[key], enNode[key]);
                  continue;
                }

                let metaEntry = metaNode[key];
                if (!metaEntry || typeof metaEntry !== "object") continue;

                const lastAuto = metaEntry.lastAutoTarget;
                const status = metaEntry.status;
                const englishBefore = metaEntry.lastSource;
                const englishNow = enNode?.[key] || englishBefore;

                if (status === "auto" &&
                    lastAuto != null &&
                    targetVal !== lastAuto) {

                  metaEntry.status = "manual";

                  reviewNode[key] = {
                    englishBefore,
                    englishNow,
                    previousAutoTarget: lastAuto,
                    currentManualValue: targetVal,
                    detectedAt: nowIso
                  };
                }
              }
            }

            traverse(targetObj, metaObj, reviewObj, enFullObj);
          }

          // --- merge with meta tracking + manual protection ----------------

          function mergeNested(targetObj, sourceObj, enObj, metaObj, reviewObj) {
            const nowIso = new Date().toISOString();

            for (const key of Object.keys(sourceObj)) {
              const srcVal = sourceObj[key];
              const enVal =
                isPlainObject(enObj) && Object.prototype.hasOwnProperty.call(enObj, key)
                  ? enObj[key]
                  : undefined;

              const targetHasKey = Object.prototype.hasOwnProperty.call(targetObj, key);
              const currentTargetVal = targetHasKey ? targetObj[key] : undefined;

              if (isPlainObject(srcVal)) {
                const tgtChild = ensureNestedObject(targetObj, key);
                const metaChild = ensureNestedObject(metaObj, key);
                const reviewChild = ensureNestedObject(reviewObj, key);
                const enChild =
                  isPlainObject(enVal) ? enVal : {};

                mergeNested(tgtChild, srcVal, enChild, metaChild, reviewChild);
              } else {
                // Ensure meta leaf object exists (or reuse existing)
                if (!isPlainObject(metaObj[key])) {
                  metaObj[key] = {
                    status: targetHasKey ? "manual" : "auto",
                    lastSource: null,
                    lastAutoTarget: null,
                    updatedAt: null,
                  };
                }

                const entry = metaObj[key];
                const previousLastAuto = entry.lastAutoTarget;

                // Detect manual override in this run (Case A: EN changed + DE was edited)
                if (
                  entry.status === "auto" &&
                  previousLastAuto != null &&
                  targetHasKey &&
                  currentTargetVal !== previousLastAuto
                ) {
                  entry.status = "manual";
                  // (Optional: we could also create a review entry here later,
                  // mirroring what detectManualDiffs does.)
                }

                // If now marked as manual → DO NOT overwrite this key
                if (entry.status === "manual") {
                  continue;
                }

                // Auto-managed: overwrite and record metadata
                targetObj[key] = srcVal;

                if (typeof enVal === 'string') {
                  entry.lastSource = enVal;
                }

                entry.lastAutoTarget = srcVal;
                entry.updatedAt = nowIso;
              }
            }
          }

          // 1) Detect manual edits even if EN didn't change
          detectManualDiffs(target, meta, review, enDiff);

          // 2) Apply auto translations (if any exist)
          if (Object.keys(translated).length > 0) {
            mergeNested(target, translated, enDiff, meta, review);
          }

          // --- write back target + meta/review ----------------------------

          ensureDirForFile(targetPath);
          fs.writeFileSync(targetPath, JSON.stringify(target, null, 2), 'utf8');
          console.log(`Merged PT-BR translations into ${targetPath}`);

          safeWriteJson(metaPath, meta);
          safeWriteJson(reviewPath, review);
          console.log(`Updated meta at ${metaPath} and kept review at ${reviewPath}.`);
          JS

          git add \
            messages/pt-BR.json \
            messages/.messages-meta \
            messages/.messages-manual-review

          # show staged diff if any
          if git diff --cached --quiet -- messages/pt-BR.json; then
            echo "No staged changes for messages/pt-BR.json"
          else
            echo "Staged diff for messages/pt-BR.json:"
            git --no-pager diff --cached -- messages/pt-BR.json || true
          fi

          # commit if there are staged changes
          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            SOURCE_SHA="${{ github.event.after }}"
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "[skip ci] auto translation (from commit ${SOURCE_SHA})"
            echo "Committed automated translation changes."
            # show what was committed
            echo "Files in last commit:"
            git show --name-only --pretty="" HEAD || true
            echo "Preview of committed messages/pt-BR.json:"
            git show HEAD:messages/pt-BR.json | head -n 50 || true

            TARGET_BRANCH="${{ github.ref_name }}"
            echo "Pushing to origin ${TARGET_BRANCH}..."
            git push origin "HEAD:${TARGET_BRANCH}" && echo "push ok" || echo "push failed"

          fi

      - name: Commit and push merged translations and removals
        if: startsWith(github.ref, 'refs/heads/')
        env:
          GIT_USER_NAME: "GitHub Actions Bot"
          GIT_USER_EMAIL: "actions@github.com"
          TARGET_BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          echo "Configuring git user for automated commit..."
          git config user.name "$GIT_USER_NAME"
          git config user.email "$GIT_USER_EMAIL"

          # Stage all locale + meta + review changes (including removals)
          git add \
            messages/en-US.json \
            messages/de-DE.json \
            messages/pt-BR.json \
            messages/.messages-meta \
            messages/.messages-manual-review

          if git diff --cached --quiet; then
            echo "No changes in translation/meta/review files to commit."
            exit 0
          fi

          SOURCE_SHA="${{ github.event.after }}"

          git commit -m "[skip ci] auto translation + removals sync (from commit $SOURCE_SHA)"

          echo "Pushing automated translation commit back to $TARGET_BRANCH..."
          git push origin "HEAD:${TARGET_BRANCH}"

      - name: Stop LibreTranslate container on server
        if: always() && steps.check_for_changes.outputs.changed == 'true'
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_PRIVATE_SSH_KEY }}
          script: |
            cd /home/steff_deployment/website_kite-engineer/libretranslate_docker

            echo "Stopping LibreTranslate service via docker compose..."
            docker compose down || echo "docker compose down failed (container may already be stopped)."


  run-search-index-script:
    name: Run the Meilisearch index
    needs: translate-content
    permissions:
      contents: read
      issues: read
      pull-requests: read
      packages: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup Node server environment
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Install Dependencies
        run: npm ci

      - name: Run Meilisearch indexing
        run: npx tsx scripts/search-indexer/index.ts
        env:
          MEILI_HOST: ${{ secrets.MEILISEARCH_HOST }}
          MEILISEARCH_API_KEY: ${{ secrets.MEILISEARCH_API_KEY }}

  versioning:
    name: Running Semversioning
    needs: run-search-index-script
    permissions:
      contents: write
      issues: write
      pull-requests: write

    runs-on: ubuntu-latest

    steps:
      - name: Checkout the repository code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.SEMVERSIONING }}

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Install Dependencies
        run: npm ci

      - name: Run Semantic Release
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.SEMVERSIONING }}

      - name: Verify semantic-release tag
        run: |
          echo "Latest tag: $(git describe --tags --abbrev=0)"
          echo "Tag SHA:    $(git rev-list -n 1 v1.14.8)"
          echo "HEAD SHA:   $(git rev-parse HEAD)"
          git log -1 --oneline
