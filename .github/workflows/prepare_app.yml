name: Prepare for build and push
on:
  push:
    branches:
      - dev
      - development
      - workflow-test

jobs:
  translate-content:
    name: Translates new content
    permissions:
      contents: write
      issues: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - name: Get current run ID as Env
        env:
          RUN_ID: ${{ github.run_id }}
        run: echo "Current run ID is $RUN_ID"

      - name: Checkout repo (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node server environment
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Check for changes in en-US.json
        id: check_for_changes
        run: |
          set -euo pipefail

          BEFORE_SHA="${{ github.event.before }}"
          AFTER_SHA="${{ github.sha }}"

          # Handle first push to branch (before == all zeros)
          if [ "$BEFORE_SHA" = "0000000000000000000000000000000000000000" ]; then
            echo "First push to this branch – diffing against empty tree."
            BEFORE_SHA="$(git hash-object -t tree /dev/null)"
          fi

          echo "Comparing commits: before=$BEFORE_SHA after=$AFTER_SHA"

          CHANGED_FILES="$(git diff --name-only "$BEFORE_SHA" "$AFTER_SHA")"

          echo "Files with changes in this push:"
          echo "$CHANGED_FILES"

          # export outputs in the modern recommended way
          {
            echo "files<<EOF"
            echo "$CHANGED_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          if echo "$CHANGED_FILES" | grep -q 'messages/en-US.json'; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create the diff between the latest and previous push in en-US.json
        if: steps.check_for_changes.outputs.changed == 'true'
        id: compute_diff
        run: |
          set -euo pipefail

          PREV_COMMIT="${{ github.event.before }}"
          CUR_COMMIT="${{ github.sha }}"
          FILE_PATH="messages/en-US.json"

          # Get previous content and check availability of the file
          if git cat-file -e "${PREV_COMMIT}:${FILE_PATH}" 2>/dev/null; then
            git show "${PREV_COMMIT}:${FILE_PATH}" > /tmp/en-US.prev.json
          else
            # File didn´t exist in the previous commit
            echo '{}' > /tmp/en-US.prev.json
          fi

          # Current content (must exist)
          if [ -f "$FILE_PATH" ]; then
            cp "$FILE_PATH" /tmp/en-US.cur.json
          else
            # IF removed in the commit, treat as empty
            echo '{}' > /tmp/en-US.cur.json
          fi

          # Node script: reads prev & cur, computes nested diff (added/changed only), writes result
          node <<'NODE'
          const fs = require('fs');

          function readJson(path) {
            try {
              return JSON.parse(fs.readFileSync(path, 'utf8'));
            } catch (e) {
              console.error(`Failed to parse ${path}:`, e.message);
              process.exit(2);
            }
          }

          // deepEqual that handles primitives, arrays, objects (order matters for arrays and object keys compared by keys)
          function deepEqual(a, b) {
            if (a === b) return true;

            // handle NaN
            if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) return true;

            if (a == null || b == null) return a === b; // covers null/undefined

            if (typeof a !== typeof b) return false;

            if (typeof a !== 'object') return a === b;

            // Arrays
            if (Array.isArray(a) || Array.isArray(b)) {
              if (!Array.isArray(a) || !Array.isArray(b)) return false;
              if (a.length !== b.length) return false;
              for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) return false;
              }
              return true;
            }

            // Plain objects
            const aKeys = Object.keys(a);
            const bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;
            // ensure same keys
            for (const k of aKeys) {
              if (!Object.prototype.hasOwnProperty.call(b, k)) return false;
              if (!deepEqual(a[k], b[k])) return false;
            }
            return true;
          }

          // computeDiff: only include keys present in `cur` (so deletions are ignored)
          // returns `undefined` if no change at this node, otherwise returns an object/primitive representing the new value
          function computeDiff(prev, cur) {
            // If either side is a primitive (or null), compare directly
            if (typeof prev !== 'object' || prev === null || typeof cur !== 'object' || cur === null) {
              if (deepEqual(prev, cur)) return undefined;
              return cur;
            }

            const keys = Object.keys(cur); // only iterate current keys -> deletions ignored
            const out = {};
            let any = false;

            for (const k of keys) {
              if (!(k in prev)) {
                // added key (or previously missing)
                out[k] = cur[k];
                any = true;
                continue;
              }

              const subPrev = prev[k];
              const subCur = cur[k];

              if (typeof subPrev === 'object' && subPrev !== null && typeof subCur === 'object' && subCur !== null) {
                const subDiff = computeDiff(subPrev, subCur);
                if (subDiff !== undefined) {
                  out[k] = subDiff;
                  any = true;
                }
              } else if (!deepEqual(subPrev, subCur)) {
                out[k] = subCur;
                any = true;
              }
            }

            return any ? out : undefined;
          }

          const prev = readJson('/tmp/en-US.prev.json');
          const cur = readJson('/tmp/en-US.cur.json');

          const diff = computeDiff(prev, cur) || {};

          fs.writeFileSync('/tmp/en-US.changed.json', JSON.stringify(diff, null, 2), 'utf8');
          console.log('Wrote /tmp/en-US.changed.json (diff object).');
          NODE

          # export path of diff as step output
          echo "diff_path=/tmp/en-US.changed.json" >> $GITHUB_OUTPUT

      - name: Prepare mapping for translation and reconstruction
        if: steps.check_for_changes.outputs.changed == 'true'
        id: translation_preparation
        run: |
          set -euo pipefail
          node <<'JS'

          const fs = require('fs');

          // Read the path to changed.json from GitHub output or env variable
          const diffPath = process.env.DIFF_PATH || '/tmp/en-US.changed.json';

          if (!fs.existsSync(diffPath)) {
            console.error(`Changed file not found at ${diffPath}`);
            process.exit(1);
          }

          // Read and parse changed.json
          let changedJson;
          try {
            changedJson = JSON.parse(fs.readFileSync(diffPath, 'utf8'));
          } catch (e) {
            console.error(`Failed to parse ${diffPath}:`, e.message);
            process.exit(2);
          }

          /**
          * Recursively traverses a nested object to extract leaf string values.
          * Returns both nested structure and flat list with dot-notation paths.
          * @param {Object} obj - JSON object to traverse
          * @param {string} prefix - dot-notation prefix
          * @param {Object} nestedResult - accumulates nested structure
          * @param {Array} flatResult - accumulates flat array
          */
          function extractLeafStringsDual(obj, prefix = '', nestedResult = {}, flatResult = []) {
            for (const key of Object.keys(obj)) {
              const value = obj[key];
              const fullPath = prefix ? `${prefix}.${key}` : key;

              if (value && typeof value === 'object' && !Array.isArray(value)) {
                nestedResult[key] = {};
                extractLeafStringsDual(value, fullPath, nestedResult[key], flatResult);
              } else if (typeof value === 'string') {
                nestedResult[key] = value;
                flatResult.push({ path: fullPath, value });
              }
            }
            return { nested: nestedResult, flat: flatResult };
          }

          // Run extraction
          const { nested, flat } = extractLeafStringsDual(changedJson);

          // Write outputs
          fs.writeFileSync('/tmp/en-US.keys-nested.json', JSON.stringify(nested, null, 2), 'utf8');
          fs.writeFileSync('/tmp/en-US.keys-dot.json', JSON.stringify(flat, null, 2), 'utf8');
          const content = fs.readFileSync('/tmp/en-US.keys-nested.json','utf8')
          console.log('This is \'/tmp/en-US.keys-nested.json\' content aka the delta:\n' + content);
          JS

      - name: Start LibreTranslate container on server
        if: steps.check_for_changes.outputs.changed == 'true'
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_PRIVATE_SSH_KEY }}
          script: |
            set -euo pipefail

            cd /home/steff_deployment/website_kite-engineer/libretranslate_docker

            echo "Starting LibreTranslate service via docker compose..."
            docker compose up -d

            echo "Waiting for LibreTranslate container health status..."
            MAX_RETRIES=24   # ~2 minutes total (24 * 5s)
            SLEEP_SECONDS=5

            i=1
            while [ "$i" -le "$MAX_RETRIES" ]; do
              STATUS=$(docker inspect -f '{{.State.Health.Status}}' libretranslate 2>/dev/null || echo "starting")
              echo "Attempt $i/$MAX_RETRIES: current status=$STATUS"

              if [ "$STATUS" = "healthy" ]; then
                echo "LibreTranslate is healthy and ready."
                exit 0
              fi

              if [ "$STATUS" = "unhealthy" ]; then
                echo "LibreTranslate container is unhealthy. Aborting."
                docker logs libretranslate || true
                exit 1
              fi

              i=$((i+1))
              sleep "$SLEEP_SECONDS"
            done

            echo "Timed out waiting for LibreTranslate to become healthy."
            docker logs libretranslate || true
            exit 1

      - name: Translate nested keys (target = de)
        if: steps.check_for_changes.outputs.changed == 'true'
        env:
          TARGET_LANG: de
          TRANSLATE_API_KEY: ${{ secrets.TRANSLATE_API_KEY }}
          KEYS_NESTED: /tmp/en-US.keys-nested.json
          OUTPUT_TRANSLATED: /tmp/en-US.changed.translated.de.json
          OUTPUT_ERRORS: /tmp/en-US.translation-errors.de.json
          API_URL: https://translate.kite-engineer.de/translate
        run: |
          set -euo pipefail

          node -v || (echo "Node not found" && exit 2)

          node <<'JS'
          (async () => {
            const fs = require('fs');

            const nestedTemplatePath = process.env.KEYS_NESTED;
            const outTranslatedPath = process.env.OUTPUT_TRANSLATED;
            const outErrorsPath = process.env.OUTPUT_ERRORS;
            const apiUrl = process.env.API_URL;
            const apiKey = process.env.TRANSLATE_API_KEY || '';
            const target = process.env.TARGET_LANG;

            if (!fs.existsSync(nestedTemplatePath)) {
              console.error(`Nested template missing: ${nestedTemplatePath}`);
              process.exit(1);
            }

            const nested = JSON.parse(fs.readFileSync(nestedTemplatePath, 'utf8'));
            const stat = fs.statSync(nestedTemplatePath);
            console.log(`Loaded nested template: ${nestedTemplatePath} (size=${stat.size}, mtime=${stat.mtime.toISOString()})`);
            console.log('Nested template (preview):', JSON.stringify(nested, null, 2).slice(0, 2000));

            // Helper: build request body for the API
            function buildRequestBody(q) {
              return {
                q,
                source: "auto",
                target,
                format: "text",
                api_key: apiKey
              };
            }

            const errors = [];
            let successCount = 0;
            let failCount = 0;

            // Traverse nested object recursively and translate string leaves in-place.
            async function traverseAndTranslate(obj, prefix = '') {
              for (const key of Object.keys(obj)) {
                const value = obj[key];
                const path = prefix ? `${prefix}.${key}` : key;

                if (value && typeof value === 'object' && !Array.isArray(value)) {
                  await traverseAndTranslate(value, path);
                  continue;
                }

                if (typeof value === 'string') {
                  if (value.trim() === '') {
                    obj[key] = '';
                    continue;
                  }

                  const body = buildRequestBody(value);

                  // create a nonce for this request
                  const nonce = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                  console.log(`[${nonce}] request at ${new Date().toISOString()} path=${path}`);

                  let resp;
                  try {
                    resp = await fetch(apiUrl, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-Debug-Nonce': nonce,
                        'Cache-Control': 'no-cache'
                      },
                      body: JSON.stringify(body),
                    });
                  } catch (err) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: err.message }
                    });
                    console.log(`[${nonce}] fetch failed: ${err.message}`);
                    continue;
                  }

                  let respText = '';
                  try {
                    // log response status & headers
                    console.log(`[${nonce}] response at ${new Date().toISOString()} status=${resp.status} statusText=${resp.statusText}`);
                    for (const [k, v] of resp.headers.entries()) {
                      console.log(`[${nonce}] resp-header ${k}: ${v}`);
                    }

                    respText = await resp.text();
                    console.log(`API Response raw: ${respText}`);

                    if (!resp.ok) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText
                      });
                      continue;
                    }

                    let parsed;
                    try {
                      parsed = JSON.parse(respText);
                      console.log(`[${nonce}] API Response parsed: ${JSON.stringify(parsed)}`);
                    } catch (e) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText,
                        parseError: e.message
                      });
                      continue;
                    }

                    const translatedText = parsed && parsed.translatedText;
                    console.log(`[${nonce}] Extracted translatedText: ${JSON.stringify(translatedText)}`);
                    if (typeof translatedText !== 'string') {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseJson: parsed,
                        note: "translatedText missing or not a string"
                      });
                      continue;
                    }

                    // success: replace value in-place
                    obj[key] = translatedText;
                    successCount++;
                  } catch (e) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: e.message }
                    });
                    console.log(`[${nonce}] unexpected error: ${e.message}`);
                    continue;
                  }
                }
                // non-strings are left unchanged
              }
            }

            // run traversal & translation
            await traverseAndTranslate(nested, '');

            // Write outputs (atomic-ish: write tmp then rename)
            const tmpOut = outTranslatedPath + '.tmp';
            fs.writeFileSync(tmpOut, JSON.stringify(nested, null, 2), 'utf8');

            // validate by parsing back
            try {
              const parsedCheck = JSON.parse(fs.readFileSync(tmpOut, 'utf8'));
              // move into place
              fs.renameSync(tmpOut, outTranslatedPath);
            } catch (e) {
              errors.push({ note: 'validation_failed', message: e.message });
              // keep tmp file for debugging
              console.error('Validation of output JSON failed:', e.message);
            }

            fs.writeFileSync(outErrorsPath, JSON.stringify({ successCount, failCount, errors }, null, 2), 'utf8');

            const outStat = fs.statSync(outTranslatedPath);
            console.log(`Wrote translated file: ${outTranslatedPath} (size=${outStat.size}, mtime=${outStat.mtime.toISOString()})`);
            console.log('Translated file (preview):', fs.readFileSync(outTranslatedPath,'utf8').slice(0,2000));

            console.log(`Translation run complete for target=${target}: success=${successCount}, fail=${failCount}`);
            if (failCount > 0) {
              console.log(`See error summary: ${outErrorsPath}`);
            } else {
              console.log(`All keys translated successfully. Output: ${outTranslatedPath}`);
            }
          })();
          JS

      - name: Translate nested keys (target = pt-BR)
        if: steps.check_for_changes.outputs.changed == 'true'
        env:
          TARGET_LANG: pt-BR
          TRANSLATE_API_KEY: ${{ secrets.TRANSLATE_API_KEY }}
          KEYS_NESTED: /tmp/en-US.keys-nested.json
          OUTPUT_TRANSLATED: /tmp/en-US.changed.translated.pt-BR.json
          OUTPUT_ERRORS: /tmp/en-US.translation-errors.pt-BR.json
          API_URL: https://translate.kite-engineer.de/translate
        run: |
          set -euo pipefail

          node -v || (echo "Node not found" && exit 2)

          node <<'JS'
          (async () => {
            const fs = require('fs');

            const nestedTemplatePath = process.env.KEYS_NESTED;
            const outTranslatedPath = process.env.OUTPUT_TRANSLATED;
            const outErrorsPath = process.env.OUTPUT_ERRORS;
            const apiUrl = process.env.API_URL;
            const apiKey = process.env.TRANSLATE_API_KEY;
            const target = process.env.TARGET_LANG;

            if (!fs.existsSync(nestedTemplatePath)) {
              console.error(`Nested template missing: ${nestedTemplatePath}`);
              process.exit(1);
            }

            const nested = JSON.parse(fs.readFileSync(nestedTemplatePath, 'utf8'));
            const stat = fs.statSync(nestedTemplatePath);
            console.log(`Loaded nested template: ${nestedTemplatePath} (size=${stat.size}, mtime=${stat.mtime.toISOString()})`);
            console.log('Nested template (preview):', JSON.stringify(nested, null, 2).slice(0, 2000));

            // Helper: build request body for the API
            function buildRequestBody(q) {
              return {
                q,
                source: "auto",
                target,
                format: "text",
                api_key: apiKey
              };
            }

            const errors = [];
            let successCount = 0;
            let failCount = 0;

            // Traverse nested object recursively and translate string leaves in-place.
            async function traverseAndTranslate(obj, prefix = '') {
              // Iterate keys to keep original order
              for (const key of Object.keys(obj)) {
                const value = obj[key];
                const path = prefix ? `${prefix}.${key}` : key;

                if (value && typeof value === 'object' && !Array.isArray(value)) {
                  // recurse
                  await traverseAndTranslate(value, path);
                  continue;
                }

                if (typeof value === 'string') {
                  // Skip empty strings (choose to keep empty translated)
                  if (value.trim() === '') {
                    obj[key] = '';
                    continue;
                  }

                  const body = buildRequestBody(value);

                  // create a nonce for this request
                  const nonce = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                  console.log(`[${nonce}] request at ${new Date().toISOString()} path=${path}`);

                  let resp;
                  try {
                    resp = await fetch(apiUrl, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-Debug-Nonce': nonce,
                        'Cache-Control': 'no-cache'
                      },
                      body: JSON.stringify(body),
                    });
                  } catch (err) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: err.message }
                    });
                    console.log(`[${nonce}] fetch failed: ${err.message}`);
                    continue;
                  }

                  let respText = '';
                  try {
                    // log response status & headers
                    console.log(`[${nonce}] response at ${new Date().toISOString()} status=${resp.status} statusText=${resp.statusText}`);
                    for (const [k, v] of resp.headers.entries()) {
                      console.log(`[${nonce}] resp-header ${k}: ${v}`);
                    }

                    respText = await resp.text();
                    console.log(`API Response raw: ${respText}`);

                    if (!resp.ok) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText
                      });
                      continue;
                    }

                    let parsed;
                    try {
                      parsed = JSON.parse(respText);
                      console.log(`[${nonce}] API Response parsed: ${JSON.stringify(parsed)}`);
                    } catch (e) {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseText: respText,
                        parseError: e.message
                      });
                      continue;
                    }

                    const translatedText = parsed && parsed.translatedText;
                    console.log(`[${nonce}] Extracted translatedText: ${JSON.stringify(translatedText)}`);
                    if (typeof translatedText !== 'string') {
                      failCount++;
                      errors.push({
                        path, value, target,
                        requestBody: body,
                        status: resp.status,
                        statusText: resp.statusText,
                        responseJson: parsed,
                        note: "translatedText missing or not a string"
                      });
                      continue;
                    }

                    // success: replace value in-place
                    obj[key] = translatedText;
                    successCount++;
                  } catch (e) {
                    failCount++;
                    errors.push({
                      path, value, target,
                      requestBody: body,
                      error: { message: e.message }
                    });
                    console.log(`[${nonce}] unexpected error: ${e.message}`);
                    continue;
                  }
                } // end if string
                // non-strings (numbers, booleans, null, arrays) are left unchanged
              }
            }

            // run traversal & translation
            await traverseAndTranslate(nested, '');

            // Write outputs (atomic-ish: write tmp then rename)
            const tmpOut = outTranslatedPath + '.tmp';
            fs.writeFileSync(tmpOut, JSON.stringify(nested, null, 2), 'utf8');

            // validate by parsing back
            try {
              const parsedCheck = JSON.parse(fs.readFileSync(tmpOut, 'utf8'));
              // move into place
              fs.renameSync(tmpOut, outTranslatedPath);
            } catch (e) {
              errors.push({ note: 'validation_failed', message: e.message });
              // keep tmp file for debugging
              console.error('Validation of output JSON failed:', e.message);
            }
            fs.writeFileSync(outErrorsPath, JSON.stringify({ successCount, failCount, errors }, null, 2), 'utf8');

            const outStat = fs.statSync(outTranslatedPath);
            console.log(`Wrote translated file: ${outTranslatedPath} (size=${outStat.size}, mtime=${outStat.mtime.toISOString()})`);
            console.log('Translated file (preview):', fs.readFileSync(outTranslatedPath,'utf8').slice(0,2000));

            console.log(`Translation run complete for target=${target}: success=${successCount}, fail=${failCount}`);
            if (failCount > 0) {
              console.log(`See error summary: ${outErrorsPath}`);
            } else {
              console.log(`All keys translated successfully. Output: ${outTranslatedPath}`);
            }
          })();
          JS

      - name: Merge DE translations into existing de-DE.json
        run: |
          set -euo pipefail

          if [ -f /tmp/en-US.changed.translated.de.json ]; then
            echo "Translated (incoming):"
            head -n 50 /tmp/en-US.changed.translated.de.json
          else
            echo "No translated file at /tmp/en-US.changed.translated.de.json"
          fi

          if [ -f messages/de-DE.json ]; then
            echo "Repo target BEFORE merge:"
            head -n 50 messages/de-DE.json
          else
            echo "Repo target messages/de-DE.json does not exist yet."
          fi

          node <<'JS'
          const fs = require('fs');
          const path = require('path');

          // Paths
          const translatedPath = '/tmp/en-US.changed.translated.de.json';
          const targetPath = 'messages/de-DE.json';
          const metaPath = 'messages/.messages-meta/de-DE.meta.json';
          const reviewPath = 'messages/.messages-manual-review/de-DE.review.json';
          const enDiffPath = '/tmp/en-US.keys-nested.json'; // nested English diff (changed keys)

          // --- helpers ----------------------------------------------------

          function ensureDirForFile(filePath) {
            const dir = path.dirname(filePath);
            if (dir && !fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
          }

          function safeReadJson(filePath, fallback = {}) {
            if (!fs.existsSync(filePath) || fs.statSync(filePath).size === 0) {
              return fallback;
            }
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.warn(`Warning: failed to parse ${filePath}, using fallback: ${e.message}`);
              return fallback;
            }
          }

          function safeWriteJson(filePath, obj) {
            ensureDirForFile(filePath);
            fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), 'utf8');
          }

          // --- load translated diff ---------------------------------------

          let translated = {};
          if (fs.existsSync(translatedPath)) {
            translated = safeReadJson(translatedPath, {});
            console.log("DE translation available for merge.");
          } else {
            console.log("No DE translation available — running only manual detection.");
          }

          const translated = safeReadJson(translatedPath, {});

          // --- load English nested diff (same keys, en-US side) -----------

          const enDiff = safeReadJson(enDiffPath, {});

          // --- load target locale file (de-DE.json) -----------------------

          let target = safeReadJson(targetPath, {});
          if (Object.keys(target).length === 0) {
            console.log(`${targetPath} missing or empty — starting from empty object`);
          }

          // --- load / initialize meta + review (nested) -------------------

          let meta = safeReadJson(metaPath, {});
          let review = safeReadJson(reviewPath, {});

          function isPlainObject(value) {
            return (
              value !== null &&
              typeof value === 'object' &&
              !Array.isArray(value)
            );
          }

          // helper to ensure nested object structure for meta / target
          function ensureNestedObject(obj, key) {
            if (!isPlainObject(obj[key])) {
              obj[key] = {};
            }
            return obj[key];
          }

          function detectManualDiffs(targetObj, metaObj, reviewObj, enFullObj = {}) {
            const nowIso = new Date().toISOString();

            function traverse(targetNode, metaNode, reviewNode, enNode) {
              for (const key of Object.keys(targetNode)) {
                const targetVal = targetNode[key];

                // Nested structure?
                if (isPlainObject(targetVal)) {
                  if (!isPlainObject(metaNode[key])) metaNode[key] = {};
                  if (!isPlainObject(reviewNode[key])) reviewNode[key] = {};
                  if (!isPlainObject(enNode?.[key])) enNode[key] = {};

                  traverse(targetVal, metaNode[key], reviewNode[key], enNode[key]);
                  continue;
                }

                let metaEntry = metaNode[key];
                if (!metaEntry || typeof metaEntry !== "object") continue;

                const lastAuto = metaEntry.lastAutoTarget;
                const status = metaEntry.status;
                const englishBefore = metaEntry.lastSource;
                const englishNow = enNode?.[key] || englishBefore;

                if (status === "auto" &&
                    lastAuto != null &&
                    targetVal !== lastAuto) {

                  metaEntry.status = "manual";

                  reviewNode[key] = {
                    englishBefore,
                    englishNow,
                    previousAutoTarget: lastAuto,
                    currentManualValue: targetVal,
                    detectedAt: nowIso
                  };
                }
              }
            }

            traverse(targetObj, metaObj, reviewObj, enFullObj);
          }

          function mergeNested(targetObj, sourceObj, enObj, metaObj) {
            const nowIso = new Date().toISOString();

            for (const key of Object.keys(sourceObj)) {
              const srcVal = sourceObj[key];
              const enVal =
                isPlainObject(enObj) && Object.prototype.hasOwnProperty.call(enObj, key)
                  ? enObj[key]
                  : undefined;

              const targetHasKey = Object.prototype.hasOwnProperty.call(targetObj, key);
              const currentTargetVal = targetHasKey ? targetObj[key] : undefined;

              if (isPlainObject(srcVal)) {
                // nested object branch
                const tgtChild = ensureNestedObject(targetObj, key);
                const metaChild = ensureNestedObject(metaObj, key);

                const enChild =
                  isPlainObject(enVal) ? enVal : {};

                mergeNested(tgtChild, srcVal, enChild, metaChild);
              } else {
                // --- LEAF BRANCH: protect manual translations ----------------

                // Ensure meta leaf object exists (or reuse existing)
                if (!isPlainObject(metaObj[key])) {
                  metaObj[key] = {
                    status: targetHasKey ? "manual" : "auto",
                    lastSource: null,
                    lastAutoTarget: null,
                    updatedAt: null,
                  };
                }

                const entry = metaObj[key];
                const previousLastAuto = entry.lastAutoTarget;

                // Detect manual override:
                // If this key was auto-managed and the current stored translation
                // differs from the last auto output -> someone edited it by hand.
                if (
                  entry.status === "auto" &&
                  previousLastAuto != null &&
                  targetHasKey &&
                  currentTargetVal !== previousLastAuto
                ) {
                  entry.status = "manual";
                }

                // If now marked as manual → DO NOT overwrite this key
                if (entry.status === "manual") {
                  // We deliberately leave lastSource/lastAutoTarget/updatedAt unchanged here.
                  // Later we will use this to drive manual review.
                  continue;
                }

                // Auto-managed: overwrite and record metadata
                targetObj[key] = srcVal;

                // Only update lastSource if we actually have English text for this key
                if (typeof enVal === 'string') {
                  entry.lastSource = enVal;
                }

                entry.lastAutoTarget = srcVal;
                entry.updatedAt = nowIso;
              }
            }
          }

          // Detect manual edits even when EN did not change
          detectManualDiffs(target, meta, review, enDiff);

          // Then apply auto-translations (if available)
          mergeNested(target, translated, enDiff, meta, review);

          // --- write back target + meta/review ----------------------------

          ensureDirForFile(targetPath);
          fs.writeFileSync(targetPath, JSON.stringify(target, null, 2), 'utf8');
          console.log(`Merged DE translations into ${targetPath}`);

          safeWriteJson(metaPath, meta);
          safeWriteJson(reviewPath, review);
          console.log(`Updated meta at ${metaPath} and kept review at ${reviewPath}.`);
          JS

          git add \
            messages/de-DE.json \
            messages/.messages-meta \
            messages/.messages-manual-review

          # show staged diff if any
          if git diff --cached --quiet -- messages/de-DE.json; then
            echo "No staged changes for messages/de-DE.json"
          else
            echo "Staged diff for messages/de-DE.json:"
            git --no-pager diff --cached -- messages/de-DE.json || true
          fi

          # commit if there are staged changes
          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            SOURCE_SHA="${{ github.event.after }}"
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "[skip ci] auto translation (from commit ${SOURCE_SHA})"
            echo "Committed automated translation changes."
            # show what was committed
            echo "Files in last commit:"
            git show --name-only --pretty="" HEAD || true
            echo "Preview of committed messages/de-DE.json:"
            git show HEAD:messages/de-DE.json | head -n 50 || true
            
            TARGET_BRANCH="${{ github.ref_name }}"
            echo "Pushing to origin ${TARGET_BRANCH}..."
            git push origin "HEAD:${TARGET_BRANCH}" && echo "push ok" || echo "push failed"

          fi

      - name: Merge PT-BR translations into existing pt-BR.json
        run: |
          set -euo pipefail

          if [ -f /tmp/en-US.changed.translated.pt-BR.json ]; then
            echo "Translated (incoming):"
            head -n 50 /tmp/en-US.changed.translated.pt-BR.json
          else
            echo "No translated file at /tmp/en-US.changed.translated.pt-BR.json"
          fi

          if [ -f messages/pt-BR.json ]; then
            echo "Repo target BEFORE merge:"
            head -n 50 messages/pt-BR.json
          else
            echo "Repo target messages/pt-BR.json does not exist yet."
          fi

          node <<'JS'
          const fs = require('fs');
          const path = require('path');

          // Paths
          const translatedPath = '/tmp/en-US.changed.translated.pt-BR.json';
          const targetPath = 'messages/pt-BR.json';
          const metaPath = 'messages/.messages-meta/pt-BR.meta.json';
          const reviewPath = 'messages/.messages-manual-review/pt-BR.review.json';

          // --- helpers ----------------------------------------------------

          function ensureDirForFile(filePath) {
            const dir = path.dirname(filePath);
            if (dir && !fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
          }

          function safeReadJson(filePath, fallback = {}) {
            if (!fs.existsSync(filePath) || fs.statSync(filePath).size === 0) {
              return fallback;
            }
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.warn(`Warning: failed to parse ${filePath}, using fallback: ${e.message}`);
              return fallback;
            }
          }

          function safeWriteJson(filePath, obj) {
            ensureDirForFile(filePath);
            fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), 'utf8');
          }

          // --- load translated diff ---------------------------------------

          let translated = {};
          if (fs.existsSync(translatedPath)) {
            translated = safeReadJson(translatedPath, {});
            console.log("pt-BR translation available for merge.");
          } else {
            console.log("No pt-BR translation available — running only manual detection.");
          }

          const translated = safeReadJson(translatedPath, {});

          // --- load target locale file (pt-BR.json) -----------------------

          let target = safeReadJson(targetPath, {});
          if (Object.keys(target).length === 0) {
            console.log(`${targetPath} missing or empty — starting from empty object`);
          }

          // --- load / initialize meta + review (scaffolding only) ---------

          let meta = safeReadJson(metaPath, {});
          let review = safeReadJson(reviewPath, {});

          // --- existing mergeNested behavior (unchanged yet) --------------

          function mergeNested(targetObj, sourceObj) {
            for (const key of Object.keys(sourceObj)) {
              const srcVal = sourceObj[key];
              const tgtVal = targetObj[key];

              if (srcVal && typeof srcVal === 'object' && !Array.isArray(srcVal)) {
                if (!tgtVal || typeof tgtVal !== 'object') {
                  targetObj[key] = {};
                }
                mergeNested(targetObj[key], srcVal);
              } else {
                // CURRENT BEHAVIOR: always overwrite leaf values
                targetObj[key] = srcVal;
              }
            }
          }

          mergeNested(target, translated);

          // --- write back target + empty meta/review scaffolding -----------

          ensureDirForFile(targetPath);
          fs.writeFileSync(targetPath, JSON.stringify(target, null, 2), 'utf8');
          console.log(`Merged PT translations into ${targetPath}`);

          safeWriteJson(metaPath, meta);
          safeWriteJson(reviewPath, review);
          console.log(`Ensured meta at ${metaPath} and review at ${reviewPath} exist.`);
          JS

          git add messages/pt-BR.json

          # show staged diff if any
          if git diff --cached --quiet -- messages/pt-BR.json; then
            echo "No staged changes for messages/pt-BR.json"
          else
            echo "Staged diff for messages/pt-BR.json:"
            git --no-pager diff --cached -- messages/pt-BR.json || true
          fi

          # commit if there are staged changes
          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            SOURCE_SHA="${{ github.event.after }}"
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "[skip ci] auto translation (from commit ${SOURCE_SHA})"
            echo "Committed automated translation changes."
            # show what was committed
            echo "Files in last commit:"
            git show --name-only --pretty="" HEAD || true
            echo "Preview of committed messages/pt-BR.json:"
            git show HEAD:messages/pt-BR.json | head -n 50 || true
            echo "Pushing to origin dev..."
            git push origin dev && echo "push ok" || echo "push failed"
          fi

      - name: Commit and push merged translations
        if: |
          steps.check_for_changes.outputs.changed == 'true' &&
          (github.ref_name == 'dev' || github.ref_name == 'workflow-test')
        env:
          GIT_USER_NAME: "GitHub Actions Bot"
          GIT_USER_EMAIL: "actions@github.com"
          TARGET_BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          echo "Configuring git user for automated commit..."
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"

          # Check for changes in translation and meta files only
          git add \
            messages/de-DE.json \
            messages/pt-BR.json \
            messages/.messages-meta \
            messages/.messages-manual-review

          if git diff --cached --quiet; then
            echo "No changes in translation files to commit."
            exit 0
          fi

          # Get the SHA of the commit that triggered the workflow
          SOURCE_SHA="${{ github.event.after }}"

          # Commit with [skip ci] to prevent retriggering workflows
          git commit -m "[skip ci] auto translation de and pt added (from commit $SOURCE_SHA)"

          # Push back to the same branch
          echo "Pushing automated translation commit to $TARGET_BRANCH..."
          git push origin "$TARGET_BRANCH"

      - name: Stop LibreTranslate container on server
        if: always() && steps.check_for_changes.outputs.changed == 'true'
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_PRIVATE_SSH_KEY }}
          script: |
            cd /home/steff_deployment/website_kite-engineer/libretranslate_docker

            echo "Stopping LibreTranslate service via docker compose..."
            docker compose down || echo "docker compose down failed (container may already be stopped)."


  run-search-index-script:
    name: Run the Meilisearch index
    needs: translate-content
    permissions:
      contents: read
      issues: read
      pull-requests: read
      packages: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup Node server environment
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Install Dependencies
        run: npm ci

      - name: Run Meilisearch indexing
        run: npx tsx scripts/search-indexer/index.ts
        env:
          MEILI_HOST: ${{ secrets.MEILISEARCH_HOST }}
          MEILISEARCH_API_KEY: ${{ secrets.MEILISEARCH_API_KEY }}

  versioning:
    name: Running Semversioning
    needs: run-search-index-script
    permissions:
      contents: write
      issues: write
      pull-requests: write

    runs-on: ubuntu-latest

    steps:
      - name: Checkout the repository code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.SEMVERSIONING }}

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: "npm"

      - name: Install Dependencies
        run: npm ci

      - name: Run Semantic Release
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.SEMVERSIONING }}

      - name: Verify semantic-release tag
        run: |
          echo "Latest tag: $(git describe --tags --abbrev=0)"
          echo "Tag SHA:    $(git rev-list -n 1 v1.14.8)"
          echo "HEAD SHA:   $(git rev-parse HEAD)"
          git log -1 --oneline
